# See LICENSE for details

import os
import sys
import pluggy
import shutil
from river_core.log import logger
import river_core.utils as utils
from river_core.constants import *
import random
import re
import datetime
import pytest
from envyaml import EnvYAML

# Output globals.
# Parameter list is a list designed to get all useful info while generating things from testfloat
# It is a nested list.
# Main = [Sub1, Sub2, Sub3]
# Sub1 = [Inst, Dest, Reg1, Reg2, Mode]
# Dest, Reg1, Reg2 are again a list of values to generate the addresses from
# parameter_list
folder_dir = ''
# File_ctr is a variable to account for total number of test_cases
# file_ctr = 0

# ASM Filter
mid_header = '''
.section ".tohost","aw",@progbits
.align 6
.globl tohost
tohost: .dword 0
.align 6
.globl fromhost
fromhost: .dword 0

.section .text.init
.globl rvtest_entry_point
rvtest_entry_point:

li t0, 0x00006000
csrs mstatus, t0

la x1, begin_rvtest_data
'''

code_footer = '''rvtest_code_end:
RVMODEL_HALT'''


def convert_inst_precision(inst):
    '''
    Get the instruction precision value for convert operations
    '''
    inst_prefix = ''
    dest_prefix = ''
    if inst[-1] == 'w':
        inst_prefix = 'i32'
    elif inst[-1] == 'wu':
        inst_prefix = 'ui32'
    elif inst[-1] == 'l':
        inst_prefix = 'i64'
    elif inst[-1] == 'lu':
        inst_prefix = 'ui64'
    elif inst[-1] == 's':
        inst_prefix = 'f32'
    elif inst[-1] == 'd':
        inst_prefix = 'f64'
    elif inst[-1] == 'q':
        inst_prefix = 'f128'
    else:
        logger.error('Failed to detect a valid source instruction precision')

    if inst[-3] == 'w':
        dest_prefix = 'i32'
    elif inst[-3] == 'wu':
        dest_prefix = 'ui32'
    elif inst[-3] == 'l':
        dest_prefix = 'i64'
    elif inst[-3] == 'lu':
        dest_prefix = 'ui64'
    elif inst[-3] == 's':
        dest_prefix = 'f32'
    elif inst[-3] == 'd':
        dest_prefix = 'f64'
    elif inst[-3] == 'q':
        dest_prefix = 'f128'
    else:
        logger.error(
            'Failed to detect a valid destination instruction precision')

    return inst_prefix, dest_prefix


def inst_precision(inst):
    '''
    Get the instrucction precision for the non-convert operations
    '''

    inst_prefix = ''
    if '.s' in inst:
        inst_prefix = 'f32'
    elif '.d' in inst:
        inst_prefix = 'f64'
    elif '.q' in inst:
        inst_prefix = 'f128'
    else:
        logger.error('Failed to get the proper precision')
    return inst_prefix


def inst_alignment(inst):
    inst_align = 0
    if '.d' in inst:
        inst_align = 8
    elif '.s' in inst:
        inst_align = 4
    # TODO Could be possibly wrong, can remove Q parts for now as well
    elif '.q' in inst:
        inst_align = 16
    else:
        logger.error('Failed to get the proper precision')
    return inst_align


def create_asm(gen_file, parameter_list, gen_cmd):
    offset_mem = []
    work_dir = os.path.dirname(os.path.realpath(gen_file))
    local_folder_dir = folder_dir + '/testfloat_plugin/asm/'

    # copy stuff for asm
    logger.info('Copying Header files')
    shutil.copy(local_folder_dir + 'link.ld',
                os.path.splitext(gen_file)[0] + '.ld')

    # Substitute header files
    header = '#include "test.h"\n#include "model.h"\n'.format(
        os.path.splitext(os.path.basename(gen_file))[0])
    header += mid_header

    # Parsing from parameters
    asm_inst = parameter_list[0]

    # Get alignment values
    align = inst_alignment(asm_inst)
    # TODO check if this needs to change
    # Can come from the inst as well
    # Create test.S
    # Clean up the file data
    with open(gen_file, 'r') as gen_file_data:
        logger.debug('Reading gen files')
        gen_data = gen_file_data.read().splitlines()
    # Add steps to write to file
    assembly_file = os.path.splitext(gen_file)[0] + '.S'
    with open(assembly_file, 'w+') as asm_file_pointer:
        logger.info('Generating in the ASM file')
        # riscv-gcc uses GAS syntax so need to denote the comments with #
        generation_header = "# ASM file generated by testfloat plugin at {0}, from testfloatgen command: \n# {1} \n".format(
            datetime.datetime.now(), gen_cmd)
        asm_file_pointer.write(generation_header)
        asm_file_pointer.write(header)

        # Need to maintain an offset for the values
        offset_ctr = 0

        # TODO: Will change to original file length after testing
        # Is useful to control the number of instructions, we can probably step away from the limits for Testfloat
        for case_index in range(0, len(gen_data)):
            # for case_index in range(0, len(gen_data)):

            # Instruction types

            arthematic_inst = ['fadd.', 'fsub.', 'fmul.', 'fdiv.']
            compare_inst = ['feq.', 'flt.', 'fle.', 'fmin.', 'fmax.']
            fused_inst = ['fmadd', 'fmsub', 'fnmsub', 'fnmadd']
            convert_inst = 'cvt'
            sqrt_inst = 'sqrt'

            # TODO: Improve, nested list parsing, regex is a good alt, but need to be pefomant heavy
            if any(element in asm_inst for element in arthematic_inst):
                # Move the selection here to ensure max variety in the tests cases
                dest = random.randint(int(parameter_list[1][0]),
                                      int(parameter_list[1][1]))
                if dest == 1:
                    dest = random.randint(4,31)
                dest_reg = 'f' + str(dest)
                reg_1 = random.randint(int(parameter_list[2][0]),
                                       int(parameter_list[2][1]))
                reg_1_str = 'f' + str(reg_1)
                reg_2 = random.randint(int(parameter_list[3][0]),
                                       int(parameter_list[3][1]))
                reg_2_str = 'f' + str(reg_2)
                mode = parameter_list[4]
                case_data = gen_data[case_index].split(' ')
                offset_mem.append('0x' + str(case_data[0]))
                offset_mem.append('0x' + str(case_data[1]))
                # expected_result = '0x' + str(case_data[2])
                # exception_flag = '0x' + str(case_data[3])
                generated_asm_inst = '\ninst_{0}:\nTEST_RR_OP({1}, {2}, {3}, {4}, {5}, {6}, {7})\n'.format(
                    case_index, asm_inst, dest_reg, reg_1_str, reg_2_str, mode,
                    offset_ctr, offset_ctr + align)

                asm_file_pointer.write(generated_asm_inst)
                # Ensure that the offset generated is twice the amount
                max_offset = 2048 - (2*align)

                # Add check for 2048 limitation
                if offset_ctr == max_offset:
                    update_asm_inst = '\naddi x1, x1, {0}\n'.format(max_offset)
                    asm_file_pointer.write(update_asm_inst)
                    offset_ctr = 2 * align
                else:
                    offset_ctr += 2 * align

            elif sqrt_inst in asm_inst:
                # Move the selection here to ensure max variety in the tests cases
                dest = random.randint(int(parameter_list[1][0]),
                                      int(parameter_list[1][1]))
                if dest == 1:
                    dest = random.randint(4,31)
                dest_reg = 'f' + str(dest)
                reg_1 = random.randint(int(parameter_list[2][0]),
                                       int(parameter_list[2][1]))
                reg_1_str = 'f' + str(reg_1)
                mode = parameter_list[3]
                case_data = gen_data[case_index].split(' ')
                offset_mem.append('0x' + str(case_data[0]))
                # expected_result = '0x' + str(case_data[2])
                # exception_flag = '0x' + str(case_data[3])
                generated_asm_inst = '\ninst_{0}:\nTEST_R_OP({1}, {2}, {3}, {4}, {5})\n'.format(
                    case_index, asm_inst, dest_reg, reg_1_str, mode, offset_ctr)

                asm_file_pointer.write(generated_asm_inst)
                max_offset = 2048 - (1*align)

                # Add check for 2048 limitation
                if offset_ctr == max_offset:
                    update_asm_inst = '\naddi x1, x1, {0}\n'.format(max_offset)
                    asm_file_pointer.write(update_asm_inst)
                    offset_ctr = 1 * align
                else:
                    offset_ctr += 1 * align

            elif any(element in asm_inst for element in fused_inst):
                # Move the selection here to ensure max variety in the tests cases
                dest = random.randint(int(parameter_list[1][0]),
                                      int(parameter_list[1][1]))
                if dest == 1:
                    dest = random.randint(4,31)
                dest_reg = 'f' + str(dest)
                reg_1 = random.randint(int(parameter_list[2][0]),
                                       int(parameter_list[2][1]))
                reg_1_str = 'f' + str(reg_1)
                reg_2 = random.randint(int(parameter_list[3][0]),
                                       int(parameter_list[3][1]))
                reg_2_str = 'f' + str(reg_2)
                reg_3 = random.randint(int(parameter_list[4][0]),
                                       int(parameter_list[4][1]))
                reg_3_str = 'f' + str(reg_3)
                mode = parameter_list[5]
                case_data = gen_data[case_index].split(' ')
                offset_mem.append('0x' + str(case_data[0]))
                offset_mem.append('0x' + str(case_data[1]))
                offset_mem.append('0x' + str(case_data[3]))
                # expected_result = '0x' + str(case_data[2])
                # exception_flag = '0x' + str(case_data[3])
                generated_asm_inst = '\ninst_{0}:\nTEST_RRR_OP({1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9})\n'.format(
                    case_index, asm_inst, dest_reg, reg_1_str, reg_2_str,
                    reg_3_str, mode, offset_ctr, offset_ctr + align,
                    offset_ctr + 2 * align)

                asm_file_pointer.write(generated_asm_inst)
                max_offset = int(2048/(3*align))*(3*align) - (3*align)

                # Add check for 2048 limitation
                if offset_ctr == max_offset:
                    update_asm_inst = '\naddi x1, x1, {0}\n'.format(max_offset)
                    asm_file_pointer.write(update_asm_inst)
                    offset_ctr = 3 * align
                else:
                    offset_ctr += 3 * align

            elif convert_inst in asm_inst:
                # Move the selection here to ensure max variety in the tests cases
                prefix, suffix = convert_inst_precision(asm_inst)
                dest = random.randint(int(parameter_list[1][0]),
                                      int(parameter_list[1][1]))
                # can't select x1 as destination register
                if dest == 1:
                    dest = random.randint(4,31)
                if 'i' in suffix:
                    reg_prefix = 'x'
                elif 'f' in suffix:
                    reg_prefix = 'f'
                dest_reg = str(reg_prefix) + str(dest)

                reg_1 = random.randint(int(parameter_list[2][0]),
                                       int(parameter_list[2][1]))
                if 'i' in prefix:
                    reg_suffix = 'x'
                elif 'f' in prefix:
                    reg_suffix = 'f'
                reg_1_str = str(reg_suffix) + str(reg_1)

                mode = parameter_list[3]
                case_data = gen_data[case_index].split(' ')
                offset_mem.append('0x' + str(case_data[0]))
                offset_mem.append('0x' + str(case_data[1]))
                # expected_result = '0x' + str(case_data[2])
                # exception_flag = '0x' + str(case_data[3])
                generated_asm_inst = '\ninst_{0}:\nTEST_R_OP({1}, {2}, {3}, {4}, {5})\n'.format(
                    case_index, asm_inst, dest_reg, reg_1_str, mode, offset_ctr)

                asm_file_pointer.write(generated_asm_inst)
                max_offset = 2048 - (1*align)

                # Add check for 2048 limitation
                if offset_ctr == max_offset:
                    update_asm_inst = '\naddi x1, x1, {0}\n'.format(max_offset)
                    asm_file_pointer.write(update_asm_inst)
                    offset_ctr = 1 * align
                else:
                    offset_ctr += 1 * align

            elif any(element in asm_inst for element in compare_inst):
                # Move the selection here to ensure max variety in the tests cases
                dest = random.randint(int(parameter_list[1][0]),
                                      int(parameter_list[1][1]))
                dest_reg = 'x' + str(dest)
                reg_1 = random.randint(int(parameter_list[2][0]),
                                       int(parameter_list[2][1]))
                reg_1_str = 'f' + str(reg_1)
                reg_2 = random.randint(int(parameter_list[3][0]),
                                       int(parameter_list[3][1]))
                reg_2_str = 'f' + str(reg_2)
                if 'eq' in asm_inst:
                    mode = "010"
                elif ('lt' in asm_inst) or ('max' in asm_inst):
                    mode = "001"
                elif ('le' in asm_inst) or ('min' in asm_inst):
                    mode = "000"
                case_data = gen_data[case_index].split(' ')
                offset_mem.append('0x' + str(case_data[0]))
                offset_mem.append('0x' + str(case_data[1]))
                generated_asm_inst = '\ninst_{0}:\nTEST_RR_OP({1}, {2}, {3}, {4}, {5}, {6}, {7})\n'.format(
                    case_index, asm_inst, dest_reg, reg_1_str, reg_2_str, mode,
                    offset_ctr, offset_ctr + align)

                asm_file_pointer.write(generated_asm_inst)
                max_offset = 2048 - (2*align)

                # Add check for 2048 limitation
                if offset_ctr == max_offset:
                    update_asm_inst = '\naddi x1, x1, {0}\n'.format(max_offset)
                    asm_file_pointer.write(update_asm_inst)
                    offset_ctr = 2 * align
                else:
                    offset_ctr += 2 * align

            else:
                logger.error(
                    'Failed to detect any instructions \nEmpty ASM file will be generated\nExiting the framework'
                )
                raise SystemError

        # Finish the code section
        asm_file_pointer.write(code_footer + '\n\n')
        # Need to write the offsets here
        data_header = '.data\n.align {0}\n.globl begin_rvtest_data\nbegin_rvtest_data:\n'.format(
            align)
        asm_file_pointer.write(data_header)
        for memory in offset_mem:
            if align==8:
                asm_file_pointer.write('.dword ' + str(memory) + '\n')
            else:
                asm_file_pointer.write('.word ' + str(memory) + '\n')
        asm_file_pointer.write(
            '.align {0}; .global end_rvtest_data; end_rvtest_data:\n'.format(
                align))


def gen_cmd_list(gen_config, seed, count, output_dir, module_dir):

    global folder_dir
    folder_dir = module_dir
    logger.debug('Now generating commands for gen plugin')
    try:
        env_gen_list = EnvYAML(gen_config)
    except:
        logger.error("Is your plugin YAML file properly configured?")
        raise SystemExit

    inst_yaml_list = utils.load_yaml(gen_config)

    # INIT Vars

    setup_dir = ''
    testfloat_bin = ''
    run_command = []

    for key, value in inst_yaml_list.items():
        if key == 'gen_binary_path':
            testfloat_bin = inst_yaml_list[key]

            # Check if testfloat is there on path
            if shutil.which(testfloat_bin) is None:
                logger.error(
                    'Plugin requires testfloat to be installed and executable')
                raise SystemExit

        # Directory for output
        dirname = output_dir + '/testfloat'

        if re.search('^set', key):

            inst_list = inst_yaml_list[key]['inst']
            # Using index so as to ensure that we can iterate both
            for inst_list_index in range(0, len(inst_list)):

                rounding_mode_gen = ''
                rounding_mode_int = 0
                param_list = []
                inst = inst_list[inst_list_index]
                param_list.append(inst)
                # Dest
                dest = inst_yaml_list[key]['dest'].split(',')
                param_list.append(dest)
                # Register 1
                reg1 = inst_yaml_list[key]['reg1'].split(',')
                param_list.append(reg1)
                tests_per_instruction = int(
                    inst_yaml_list[key]['tests_per_instruction'])

                # Get inst info
                arthematic_inst = ['fadd.', 'fsub.', 'fmul.', 'fdiv.']
                compare_inst = ['feq.', 'flt.', 'fle.', 'fmin.', 'fmax.']
                fused_inst = ['fmadd', 'fmsub', 'fnmsub', 'fnmadd']
                convert_inst = 'cvt'
                sqrt_inst = 'sqrt'
                gen_inst = ''
                inst_prefix = ''

                # TODO: Improve, nested list parsing, regex is a good alt, but need to be pefomant heavy
                if any(element in inst for element in arthematic_inst) or any(
                        element in inst for element in compare_inst):
                    # Register 2
                    reg2 = inst_yaml_list[key]['reg2'].split(',')
                    param_list.append(reg2)
                    gen_inst = inst[1:-2]
                    inst_prefix = inst_precision(inst)
                    gen_inst = str(inst_prefix) + '_' + gen_inst
                    # if min/max is given assume eq and generate values
                    if ('fmin' in inst) or ('fmax' in inst):
                        gen_inst = str(inst_prefix) + '_eq'

                elif any(element in inst for element in fused_inst):
                    gen_inst = 'mulAdd'
                    inst_prefix = inst_precision(inst)
                    # Register 2
                    reg2 = inst_yaml_list[key]['reg2'].split(',')
                    param_list.append(reg2)
                    # Register 3
                    reg3 = inst_yaml_list[key]['reg3'].split(',')
                    param_list.append(reg3)
                    gen_inst = str(inst_prefix) + '_' + gen_inst

                elif sqrt_inst in inst:
                    gen_inst = inst[1:-2]
                    inst_prefix = inst_precision(inst)
                    gen_inst = str(inst_prefix) + '_' + gen_inst

                # This should be last, as the generation instruction is different for convert.
                elif convert_inst in inst:
                    gen_inst = 'to'
                    prefix, suffix = convert_inst_precision(inst)
                    gen_inst = str(prefix) + '_' + gen_inst + '_' + str(suffix)

                else:
                    logger.error(
                        'No valid instruction found, exiting framework')
                    raise SystemError

                # Check for all suported inst using rounding-mode
                rounding_mode = inst_yaml_list[key].get('rounding-mode')
                if rounding_mode:
                    for rounding_mode_index in range(0, len(rounding_mode)):
                        rounding_mode_str = rounding_mode[rounding_mode_index]
                        # Convert the string to values
                        if rounding_mode_str == 'RNE':
                            rounding_mode_int = 0
                            rounding_mode_gen = '-rnear_even'
                        elif rounding_mode_str == 'RTZ':
                            rounding_mode_int = 1
                            rounding_mode_gen = '-rminMag'
                        elif rounding_mode_str == 'RDN':
                            rounding_mode_int = 2
                            rounding_mode_gen = '-rmin'
                        elif rounding_mode_str == 'RUP':
                            rounding_mode_int = 3
                            rounding_mode_gen = '-rmax'
                        elif rounding_mode_str == 'RMM':
                            rounding_mode_int = 4
                            rounding_mode_gen = '-rnear_maxMag'
                        else:
                            logger.error(
                                'Something went wrong while parsing YAML file \nIncorrect Rounding Mode for block {0}\n'
                                .format(key))
                            raise SystemExit
                        # Get other info
                        param_list.append(rounding_mode_int)
                        num_tests = inst_yaml_list[key]['num_tests']

                        for cnt_index in range(int(count)):
                            if seed == 'random':
                                gen_seed = random.randint(0, 10000)
                            else:
                                gen_seed = int(seed)
                            for num_index in range(int(num_tests)):

                                now = datetime.datetime.now()
                                output_inst = inst.replace('.', '_')
                                gen_prefix = '{0:06}_{1}'.format(
                                    gen_seed, now.strftime('%d%m_%H%M%S'))
                                test_prefix = 'testfloat_{0}_{1}_{2}_{3}_{4}'.format(
                                    key, output_inst, rounding_mode_str,
                                    num_index, gen_prefix)
                                testdir = '{0}/asm/{1}/'.format(
                                    dirname, test_prefix)

                                combine = [
                                    '{0} -seed {1} -n {2} {3} {4}'.format(
                                        testfloat_bin, gen_seed,
                                        tests_per_instruction,
                                        rounding_mode_gen, gen_inst),
                                    param_list, testdir + test_prefix + '.gen',
                                    testdir
                                ]
                                run_command.append(combine)

                else:
                    logger.warning('Rounding mode not found')
                    raise SystemError

    return run_command


def idfnc(val):
    instance = val[1][0]
    return 'Generating for inst {0}'.format(instance)


def pytest_generate_tests(metafunc):
    if 'test_input' in metafunc.fixturenames:
        test_list = gen_cmd_list(metafunc.config.getoption("configlist"),
                                 metafunc.config.getoption("seed"),
                                 metafunc.config.getoption("count"),
                                 metafunc.config.getoption("output_dir"),
                                 metafunc.config.getoption("module_dir"))
        metafunc.parametrize('test_input', test_list, ids=idfnc, indirect=True)


@pytest.fixture
def test_input(request):
    # compile tests
    logger.debug('Generating commands from test_input fixture')
    generation_param = request.param
    # This part needs to be done here as the file processing part can't be done inside gen_cmd
    os.makedirs(generation_param[3], exist_ok=True)
    (ret, out, err) = utils.sys_command_file(generation_param[0],
                                             generation_param[2])
    create_asm(generation_param[2], generation_param[1], generation_param[0])
    return ret, err


def test_eval(test_input):
    assert test_input[0] == 0
